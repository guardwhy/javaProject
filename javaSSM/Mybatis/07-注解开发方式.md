## 环境搭建

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/48-Mybatis.png" style="zoom:80%;" />

## UserMapper接口

### 查询用户（@Select）

| 注解     | 属性                    | 说明                         |
| -------- | ----------------------- | ---------------------------- |
| @Select  | value：查询SQL语句      | 查询的注解                   |
| @Results | value：是一个Result数组 | 定义映射关系                 |
| @Result  | column                  | 定义表中列                   |
|          | property                | 定义实体类中属性             |
|          | id                      | true 这是主键列，默认是false |

1. 增加通过id查询用户的方法
2. 方法上使用注解@Select("SQL语句")
3. 在SQL语句使用#{id}占位符

```java
/**
  * 通过id查询1个用户
*/
@Select("select * from user where id = #{id}")
User findUserById(int id);
```

#### 使用@Results和@Result属性

```java
/**
 * 通过id查询1个用户
*/
@Select("select * from user where id = #{id}")
@Results({
    @Result(column = "id", property = "id", id = true), // 映射主键
    @Result(column = "user_name", property = "username") // 映射普通列
})
User findUserById(int id);
```

### 修改用户（@Update）

1. 写修改方法
2. 在方法上使用注解@Update("SQL语句")
3. 占位符使用#{属性名}

```java
/**
 *  根据用户id修改用户
*/
@Update("update user set username=#{username}, address=#{address} where id=#{id}")
int updateUser(User user);
```

### 删除用户（@Delete）

1. 编写删除方法
2. 使用注解@Delete("SQL")
3. 使用#{id}，删除指定的用户

如果有外键约束，主表中记录不能删除。

```java
/**
 * 删除记录
*/
@Delete("delete from user where id=#{id}")
int deleteUser(Integer id);
```

### 新增用户（@Insert）

1. 在UserMapper接口中，增加新增用户方法
2. 使用注解@Insert("SQL语句")

```java
/**
 * 插入一条记录
*/
@Insert("insert into user values (null, #{username},#{birthday},#{sex},#{address})")
int addUser(User user);
```

#### 获取新增主键值@SelectKey

得到自增长生成的主键值

| 属性        | 说明                 |
| ----------- | -------------------- |
| statement   | 获取主键的SQL语句    |
| keyProperty | 实体类中主键的属性名 |
| keyColumn   | 表中主键列的名字     |
| resultType  | 主键数据类型         |
| before      | false 之后 true之前  |

```java
/**
 * 插入一条记录
*/
@Insert("insert into user values (null, #{username},#{birthday},#{sex},#{address})")
/**
 statement:获取主键的SQL语句
 keyProperty: 实体类中主键的属性名
 keyColumn:表中主键列的名字
 resultType:主键数据类型
 before: false 之后 true之前
*/
@SelectKey(statement = "select last_insert_id()", keyProperty = "id", keyColumn = "id", resultType = Integer.class, before = false)
int addUser(User user);
```

### 测试代码

```java
package cn.guardwhy.test;

import cn.guardwhy.dao.UserMapper;
import cn.guardwhy.domain.User;
import cn.guardwhy.utils.SessionFactoryUtils;
import org.apache.ibatis.annotations.Update;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.sql.Date;

public class TestUserMapper {
    private static SqlSessionFactory factory;
    private SqlSession session;
    private UserMapper userMapper;

    // 创建会话对象,自动提交事务
    @Before
    public void begin(){
        session = SessionFactoryUtils.getSession();
        userMapper = session.getMapper(UserMapper.class);
    }

    /***
     * 查询操作
     */
    @Test
    public void testFindUserById(){
        User user = userMapper.findUserById(1);
        System.out.println(user);
    }

    /**
     * 更新操作
     */
    @Test
    public void testUpdateUser(){
        User user = new User();
        user.setUsername("田甜");
        user.setAddress("广州");
        user.setId(4);
        int row = userMapper.updateUser(user);
        System.out.println("更新了" + row + "行");
    }


    /**
     * 添加操作
     */
    @Test
    public void testAddUser(){
        User user = new User(null, "王永强", Date.valueOf("1990-2-10"), "男", "秦阳");
        int row = userMapper.addUser(user);
        System.out.println("添加了" + row + "条记录");
        System.out.println("生成的主键:" + user.getId());
    }

    // 关闭会话
    @After
    public void end(){
        // 手动提交
        session.commit();
        session.close();
    }
}
```

## 注解实现：一对一关联查询

| 注解     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| @Select  | 查询操作                                                     |
| @Results | 配置一对一在关联映射                                         |
| @Result  | column：主表的主键<br />property：另一方属性名<br />one：配置关联关系 |
| @One     | select：查询另一张表的方法<br />fetchType： LAZY 延迟加载  EAGER 及时加载。 |

### sqlMapConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <!--在内部配置属性：先读取内部的属性,再读取外部的属性,外部的会覆盖内部的,最后外部的属性起作用-->
    <properties resource="db.properties">
        <property name="jdbc.username" value="root"/>
        <property name="jdbc.password" value="root"/>
    </properties>

    <!--定义实体类别名-->
    <typeAliases>
        <package name="cn.guardwhy.domain"/>
    </typeAliases>

    <environments default="default">
        <!-- 环境变量 -->
        <environment id="default">
            <!--事务管理器 -->
            <transactionManager type="JDBC"/>
            <!--数据源 -->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!--映射器-->
    <mappers>
        <package name="cn.guardwhy.dao"/>
    </mappers>
</configuration>
```

### UserMapper接口

```java
package cn.guardwhy.dao;

import cn.guardwhy.domain.OrderForm;
import cn.guardwhy.domain.User;
import cn.guardwhy.domain.UserInfo;
import org.apache.ibatis.annotations.*;
import org.apache.ibatis.mapping.FetchType;

import java.util.List;

/**
 * 持久化接口:UserMapper
 */
public interface UserMapper {
    /**
     * 通过id查找用户
     */
    @Select("select * from user where id = #{id}")
    @Results({
            // column:主表的主键 property:另一方的属性名, one:配置一对一的关联关系
            @Result(column = "id", property = "userInfo",
                    // select:读取另一个对象查询方法 fetchType:LAZY延迟加载,EAGER及时加载。
                    one = @One(select = "findUserInfoById", fetchType = FetchType.LAZY))
    })
    User findUserById(@Param("id") int id);

    /**
     * 通过id查询用户拓展信息
     */
    @Select("select * from user_info where id = #{id}")
    UserInfo findUserInfoById(int id);
}
```

### 测试代码

```java
/**
一对一关联查询
1. 只查询用户名和性别
2. 同时查询用户扩展信息
*/
@Test
public void testFindUserById(){
    User user = userMapper.findUserById(1);
    System.out.println("用户名:" + user.getUsername());
    UserInfo userInfo = user.getUserInfo();
    System.out.println(userInfo);
}
```

#### 执行结果

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/49-Mybatis.png" style="zoom:67%;" />

## 注解实现：一对多关联查询

| @Result注解属性 | 说明             |
| --------------- | ---------------- |
| column          | 主表的主键       |
| property        | 另一方的属性名   |
| many            | 一对多的关联映射 |

| @Many注解属性 | 说明               |
| ------------- | ------------------ |
| select        | 查询另一方的方法   |
| fetchType     | 指定是否是延迟加载 |

### UserMapper接口

#### 实现步骤

1、通过user_id查询当前用户订单的方法

```css
使用@Select注解。
```

2、修改findUserById()方法，增加1对多延迟加载配置

```css
在findUserById()方法修改注解。
在@Results注解中添加@Result注解。
```

注意：

```css
column: 为user表中的主键id
property: 对应用户表中的订单集合属性orders
```

3、many为 @Many注解

```css
select：为上面的查询方法名
fetchType：为延迟加载
```

**代码实现**

```java
package cn.guardwhy.dao;

import cn.guardwhy.domain.OrderForm;
import cn.guardwhy.domain.User;
import cn.guardwhy.domain.UserInfo;
import org.apache.ibatis.annotations.*;
import org.apache.ibatis.mapping.FetchType;

import java.util.List;

/**
 * 持久化接口:UserMapper
 */
public interface UserMapper {
    /**
     * 通过id查找用户
     */
    @Select("select * from user where id = #{id}")
    @Results({
            // column:主表的主键 property:另一方的属性名, one:配置一对一的关联关系
            @Result(column = "id", property = "userInfo",
                    // select:读取另一个对象查询方法 fetchType:LAZY延迟加载,EAGER及时加载。
                    one = @One(select = "findUserInfoById", fetchType = FetchType.LAZY)),
            // 配置1对多的关系,column:主表的主键, property：方法的属性名, many：配置一对多的关联关系
            @Result(column = "id", property = "orders", many = @Many(select = "findOrderByUserId", fetchType = FetchType.LAZY))
    })
    
    User findUserById(@Param("id") int id);
    
    /**
     * 通过userId查询这个用户所有的订单信息
     */
    @Select("select * from order_form where user_id = #{userId}")
    @Results({
            @Result(column = "user_id", property = "userId"),
            @Result(column = "create_time", property = "createTime")
    })
    List<OrderForm> findOrderByUserId(int userId);
}

```

### 测试代码

```java
/**
一对多关联查询
1. 只查用户信息
2. 查询订单信息
*/
@Test
public void testFindUserById(){
    User user = userMapper.findUserById(1);
    System.out.println("用户名:" + user.getUsername());
    /*UserInfo userInfo = user.getUserInfo();
        System.out.println(userInfo);*/

    // 1对多
    List<OrderForm> orders = user.getOrders();
    orders.forEach(System.out::println);
}
```

#### 执行结果

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/50-Mybatis.png" style="zoom:67%;" />

## 一级缓存

### 缓存概述

用mybatis从数据库中查询数据，如果有多个用户使用同一个SQL语句来查询记录，得到相同的查询结果。

如果表中记录很多，查询速度比较慢。使用缓存的目的就是为了提升查询的速度。缓存是内存中一个区域，保存已经查询过的记录。

### 缓存分类

1. 一级缓存：使用范围是在同一个会话
2. 二级缓存：可以在不同的会话中使用

### 缓存结构

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/51-Mybatis.png" style="zoom:67%;" />

**<font color = red>一级缓存的范围：</font>**在同一个会话中使用

**需求实现**: 通过同一个 sqlSession 对象，通过id查询2次，观察发出 sql 语句的次数。

#### 测试代码

```java
/**
  * 1、在同一个测试方法中查询2次
  * 2、输出用户信息
*/
@Test
public void testFirstLevelCache1(){
    // 1.打开会话
    session = SessionFactoryUtils.getSession();
    //2.在同一个会话中查询2次，观察SQL语句生成次数
    userMapper = session.getMapper(UserMapper.class);
    // 3.得到用户拓展信息
    UserInfo userInfo1 = userMapper.findUserInfoById(1);
    System.out.println(userInfo1);

    // 4.第二次查询: 使用缓存
    UserInfo userInfo2 = userMapper.findUserInfoById(1);
    System.out.println(userInfo2);
    // 5.关闭会话
    session.close();
}
```

#### 执行结果

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/52-Mybatis.png" style="zoom:67%;" />

### 一级缓存的分析

1. 第1次查询记录，将查询到的数据写入到缓存中

2. 第2次查询的时候，首先从缓存中去读取数据，如果缓存中有数据，直接返回，而不去访问数据库了。

3. 如果这个会话执行了添加，修改，删除，提交，关闭清空当前会话的1级缓存。

   ​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/53-Mybatis.png" style="zoom:80%;" />

### 一级缓存的清空

清空的方式：sqlSession 执行添加、修改、删除、提交、关闭等操作，清空 sqlSession 中的一级缓存数据。

清空的目的：为了让缓存中存放最新数据，避免脏读。

#### 测试代码

```java
/**
  * 1、第一次查询以后，提交会话
  * 2、再进行第二次查询，观察查询结果
*/
@Test
public void testFirstLevelCache2(){
    // 1.打开会话
    session = SessionFactoryUtils.getSession();
    //2.在同一个会话中查询2次，观察SQL语句生成次数
    userMapper = session.getMapper(UserMapper.class);
    // 3.得到用户拓展信息
    UserInfo userInfo1 = userMapper.findUserInfoById(1);
    System.out.println(userInfo1);

    session.commit(); // 提交,清空1级缓存

    // 第二次查询: 使用缓存
    UserInfo userInfo2 = userMapper.findUserInfoById(1);
    System.out.println(userInfo2);
}
```

#### 执行结果

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/54-Mybatis.png" style="zoom: 80%;" />

## 二级缓存

**范围**：在不同的会话中起作用

### 二级缓存(XML方式)

#### \<cache>标签作用

```css
所有在映射文件里的 select 语句都将被缓存。
所有在映射文件里 insert,update 和 delete 语句会清空缓存。
缓存使用“最近很少使用”算法来回收
每个缓存可以存储 1024 个列表或对象的引用。
缓存获取的对象不是共享的且对调用者是安全的，不会有其它的调用者或线程潜在修改。
```

#### 实体类要序列化

```java
/**
 用户扩展信息类
 */
public class UserInfo implements Serializable{
    
}
```

#### 编写用户接口

```java
/**
* 查询所有的用户拓展信息
*/
List<UserInfo> findAllUserInfo();
```

#### sqlMapConfig.xml开启二级缓存

```xml
<!--开启二级缓存-->
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

#### 创建UserMapper.xml

1. 开启二级缓存
2. 编写查询语句

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 实体类接口的类全名 -->
<mapper namespace="cn.guardwhy.dao.UserMapper">
    <!--当前的映射文件中所有的查询操作使用缓存-->
    <cache/>
    <select id="findAllUserInfo" resultType="userInfo">
        select * from user_info
    </select>
</mapper>
```

#### 测试代码

```java
@Test
/**
 * 1. 创建一个会话查询1条记录，关闭会话
 * 2. 再创建一个会话查询1条记录，关闭会话
*/
public void testFirstLevelCache3(){
    // 1.创建第一个会话
    SqlSession session1 = SessionFactoryUtils.getSession();
    UserMapper userMapper1 = session.getMapper(UserMapper.class);
    // 2.得到所有用户拓展信息
    List<UserInfo> userInfos1 = userMapper1.findAllUserInfo();
    // 2.遍历操作
    userInfos1.forEach(System.out::println);
    // 3.关闭会话
    session1.close();

    // 1.创建第一个会话
    SqlSession session2 = SessionFactoryUtils.getSession();
    UserMapper userMapper2 = session.getMapper(UserMapper.class);
    // 2.得到所有用户拓展信息
    List<UserInfo> userInfos2 = userMapper2.findAllUserInfo();
    // 2.遍历操作
    userInfos2.forEach(System.out::println);
    // 3.关闭会话
    session2.close();
}
```

##### 执行结果

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/55-Mybatis.png" style="zoom: 80%;" />

### 二级缓存(注解方式)

只需要在UserMapper接口上使用@CacheNamespace对接口中所有的查询方法使用二级缓存

#### 测试代码

```java
package cn.guardwhy.dao;

import cn.guardwhy.domain.OrderForm;
import cn.guardwhy.domain.User;
import cn.guardwhy.domain.UserInfo;
import org.apache.ibatis.annotations.*;
import org.apache.ibatis.mapping.FetchType;

import java.util.List;

/**
 * 持久化接口:UserMapper
 */
@CacheNamespace
public interface UserMapper {

    /**
     * 查询所有的用户拓展信息
    */
    @Select("select * from user_info")
    List<UserInfo> findAllUserInfo();
}
```

#### 二级缓存分析

​	<img src="https://guardwhy.oss-cn-beijing.aliyuncs.com/img/javaEE/mybatis/56-Mybatis.png" style="zoom:67%;" />